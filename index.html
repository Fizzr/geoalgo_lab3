<html>
<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<div style="border: 1px solid #000000; padding: 3px;" >
    <select id="mode">
        <option>Draw Tree</option>
        <option>Test</option>
    </select>
    <div id="buildDiv">
        <button id="build">Build Tree</button>
        Lenght:
        <input id="len" type="number" class="num">
        Start:
        <input id="start" type="number" class="num">
        Interval:
        <input id="least" type="number" class="num">
        -
        <input id="most" type="number" class="num">
    </div>
    <div id="testDiv" style="display: none;">
        <button id="test">Test</button>
        Number:
        <input id="num" type="number" class="num">
        Min length:
        <input id="min" type="number" class="num">
        Max length:
        <input id="max" type="number" class="num">
        <span id="truths"></span>
        <span id="falses"></span>
    </div>
</div>
<div id="canvasContainer" style="display: table-row;">
    <!--div style="display: table-cell;">
        <canvas id="canvas" height="1000" width="1300" style="border:1px solid #000000;"></canvas>
    </div-->
</div>

<script>
	/*const $canvas = $("#canvas");
	const canvas = $canvas[0];
	const c = canvas.getContext("2d");
	*/
	let c;
	const maxWidth = 32767;
	const nodeWidth = 40;
	const nodeHeight = 40;
	let context = [];
	let canvases = [];


	$("#mode").change(function ()
	{
       if($(this).val() == "Draw Tree")
       {
       	    $("#testDiv").hide();
       	    $("#buildDiv").show();
       }
       else
       {
	       $("#testDiv").show();
	       $("#buildDiv").hide();
       }
	});

	$("#build").click(function ()
	{
		$("#canvasContainer").empty();
		canvases.length = 0;
		context.length = 0;
		const len = parseInt($("#len").val());
		const start = parseInt($("#start").val());
		const least = parseInt($("#least").val());
		const most = parseInt($("#most").val());

		let list = [];
		let lastNum = start;
		for (let i = 0; i < len; i++)
        {
        	const random = lastNum + least + Math.floor(Math.random() * (most - least));
        	lastNum = random;
        	list.push(random);
        }
        const tree = buildTree(null, list);
		drawTree(tree);

	});

	$("#test").click(function ()
	{
		const num = parseInt($("#num").val());
		const min = parseInt($("#min").val());
		const max = parseInt($("#max").val());

		let truths = 0;
		let falses = 0;
		const $truElem = $("#truths");
		const $falsElem= $("#falses");

		for (let i = 0; i < num; i++)
        {
        	const len = min + Math.floor(Math.random() * (max-min));
        	const least = 1;
        	const most = least + Math.floor(Math.random() * len/10);
        	const small = Math.floor(Math.random() * len);
        	const big = small + Math.floor(Math.random() * len - small);
        	const res =test(len,Math.floor(Math.random()*len), least, most, small, big);
            if(res)
            	truths++;
            else
            	falses++;
            $truElem.text("True: "+ truths);
            $falsElem.text("False: "+ falses);
        }
	});

	function Node(parent, div)
    {
    	this.div = div;
    	this.parent = parent;
    	this.leftChild;
    	this.rightChild;
    	this.totNumbers = 0;
    	this.maxWeight = 0;
    	this.x;
    	this.y;
    }
    function Leaf(parent, data)
    {
        this.data = data;
        this.parent = parent;
        this.totNumbers = 1;
        this.x;
        this.y;
    }

    function buildTree(parent, list)
    {
    	let thisNode;
    	if(list.length == 0)
    		console.log("SHIT FAM!");
        if(list.length == 1)
        {
        	thisNode = new Leaf(parent, list[0]);
        }
        else
        {
        	const divIndex = Math.floor((list.length-1)/2);
	        const div = list[divIndex];
	        thisNode = new Node(parent, div);
            thisNode.leftChild = buildTree(thisNode, list.slice(0, divIndex+1));
	        thisNode.rightChild = buildTree(thisNode, list.slice(divIndex+1, list.length));
	        if(thisNode.rightChild.totNumbers == 1)
	            thisNode.maxWeight = thisNode.rightChild.data;
            else
	        	thisNode.maxWeight = thisNode.rightChild.maxWeight;
	        thisNode.totNumbers = thisNode.leftChild.totNumbers + thisNode.rightChild.totNumbers;
        }
        return thisNode;
    }


	function drawTree(tree)
	{
		const n = tree.totNumbers;
		const width = nodeWidth * Math.pow(2, Math.ceil(Math.log2(n))) *1.1 ;
		//const width = n * nodeWidth * 2;
        const height = Math.ceil(Math.log2(n)+1) * (nodeHeight * 2);
		const canvNum = Math.ceil(width / maxWidth);
        const rest = width % maxWidth;

		for (let i = 0; i < canvNum; i++)
		{
			$("#canvasContainer")
				.append($("<div/>")
					.css("display", "table-cell")
					.append($("<canvas/>")
						.attr("id", "canvas"+i)));
			let canvas = $("#canvas"+i)[0];
			canvases.push(canvas);
			context.push(canvas.getContext("2d"));
			if(i == canvNum-1 && rest != 0)
            	canvas.width = rest;
            else
                canvas.width = maxWidth;
            canvas.height = height;    //would need 7*10^30 values to exceed max allowed height
		}

		recursiveTreeDraw(tree, 0, width, width/2, 0)
	}

	//function for drawing boxes over several canvases (Big canvas)
    // assumes only 2 canvases affected
	function  bigRect(x, y, w, h, colour)
	{
		let col;
		if(colour != undefined)
            col = colour;
		else
			col = "#000000"
		const cIndex = Math.floor(x/maxWidth);
        const c = context[cIndex];
        const adjX = x % maxWidth;
        c.strokeStyle = col;
        c.rect(adjX, y, w, h);
        c.stroke();
        if(adjX+w > maxWidth)
        {
        	const c2 = context[cIndex+1];
        	c2.strokeStyle = col;
        	c2.rect(adjX - maxWidth, y, w, h);
        	c2.stroke();
        }
	}

	//function for filling boxes over several canvases (Big canvas)
	function bigFillRect(x, y, w, h, colour)
    {

        const cIndex = Math.floor(x/maxWidth);
        const c = context[cIndex];
		c.fillStyle = colour;
		const adjX = x % maxWidth;
		c.fillRect(adjX, y, w, h);
		if(adjX+w > maxWidth)
		{
			const c2 = context[cIndex+1];
			c2.fillStyle = colour;
			c2.fillRect(adjX - maxWidth, y, w, h);
		}

	}

	//function for drawing text over several canvases (Big canvas)
    // no functionality for if text supercedes the line of a canvas currently
	function bigText(string, x, y, max, colour, font)
    {
	    const cIndex = Math.floor(x/maxWidth);
	    const c = context[cIndex];
	    c.fillStyle = colour;
	    c.font = font;
	    const adjX = x % maxWidth;
	    c.fillText(string, adjX, y, max);
	    if (adjX + max >= maxWidth)
	    {
	    	const c2 = context[cIndex+1];
	    	c2.fillStyle = colour;
	    	c2.font = font;
	    	c2.fillText(string, adjX-maxWidth, y, max);
	    }
    }
    function bigInfo(tree)
    {
	    if(tree.div != undefined)
	    {
		    const col = "#000000";
		    const font = "12px Arial";
		    bigText("d: " + tree.div, tree.x +3, tree.y + 15, nodeWidth -3, col, font);
		    bigText("n: " + tree.totNumbers, tree.x +3, tree.y + 25, nodeWidth -3, col, font);
		    bigText("w: " + tree.maxWeight, tree.x +3, tree.y + 35, nodeWidth -3, col, font);
	    }
	    else
	    {
		    bigFillRect(tree.x, tree.y, nodeWidth, nodeHeight, "#00ff36");
		    bigText(tree.data, tree.x +3, tree.y+20, nodeWidth -3, "#000000", "20px Arial");
	    }
    }

	//function for drawing lines over several canvases (Big canvas)
    //Can draw over more than two canvases
    function bigLine(x1, y1, x2, y2)
    {
	    const c1Index = Math.floor(x1/maxWidth);
	    const c2Index = Math.floor(x2/maxWidth);
//	    if(c1Index != c2Index)
//        {
        	let from;
        	let to;
            if(c1Index < c2Index)
            {
            	from = c1Index;
                to = c2Index;
            }
            else
            {
            	from = c2Index;
            	to = c1Index;
            }
            for (let i = from; i <= to; i++)
            {
            	const adjX1 = x1 - (maxWidth * i);
            	const adjX2 = x2 - (maxWidth * i);
            	let c = context[i];
	            c.strokeStyle = "#000000";
            	c.beginPath();
            	c.moveTo(adjX1, y1);
            	c.lineTo(adjX2, y2);
            	c.stroke();
            }
//        }
/*
        else
        {
        	c = context[c1Index];
        	const adjX1 = x1 % maxWidth;
        	const adjX2 = x2 % maxWidth;
	        c.strokeStyle = "#000000";
        	c.beginPath();
        	c.moveTo(adjX1, y1);
        	c.lineTo(adjX2, y2);
        	c.stroke();
        }
*/
    }

	function recursiveTreeDraw(tree, smallest, biggest, mid, top)
	{
		bigRect(mid-(nodeWidth/2), top, nodeWidth, nodeHeight);
        tree.x = mid-(nodeWidth/2);
        tree.y = top;
        bigInfo(tree);

		if(tree.totNumbers > 1)
		{
			//left
            bigLine(mid, top+40, ((mid-smallest)/2) + smallest, top+80);
			//right
            bigLine(mid, top+40, ((biggest-mid)/2) + mid, top+80);

			recursiveTreeDraw(tree.leftChild, smallest, mid,(mid-smallest)/2+ smallest, top+80);
			recursiveTreeDraw(tree.rightChild, mid, biggest, ((biggest-mid)/2)+ mid, top+80);
		}
	}

	function findSplit(tree, small, big)
    {
    	if(!(tree.totNumbers == 1) && (small > tree.div || big <= tree.div))
        {
            if(big <= tree.div)
            	return findSplit(tree.leftChild, small, big);
            else
            	return findSplit(tree.rightChild, small, big);
        }
        else
        	return tree;
    }

    function takeAll(tree)
    {
        let list = [];
        if(tree.totNumbers == 1)
        	list.push(tree.data);
        else
        {
	        list = list.concat(takeAll(tree.leftChild));
	        list = list.concat(takeAll(tree.rightChild));
        }
        return list;
    }
    function search (tree, x, left)
    {
    	let list = [];
    	if(tree.totNumbers == 1)
        {
        	if(left)        //Will never be reached while going left...
	        {
		        if (tree.data >= x)
			        list.push(tree.data);
	        }
	        else
        	    if(tree.data <= x)
        			list.push(tree.data);
        }
        else
        {
        	if(!left)
            {
                if(tree.div == x)
                	list = list.concat(takeAll(tree.leftChild));
                else if(tree.div < x)
                {
	                list = list.concat(takeAll(tree.leftChild));
	                list = list.concat(search(tree.rightChild, x, left));
                }
                else
	                list = list.concat(search(tree.leftChild, x, left));
            }
            else
            {
            	if(tree.div == x)
	            {
		            list.push(x);
		            list = list.concat(takeAll(tree.rightChild));
	            }
                else if(tree.div < x)
	                list = list.concat(search(tree.rightChild, x, left));
                else
                {
	                list = list.concat(search(tree.leftChild, x, left));
	                list = list.concat(takeAll(tree.rightChild, x, left));
                }
            }
        }
	    //console.log(list);
        return list;
    }
    
    function OneDRangeQuery(tree, small, big)
    {
	    const split = findSplit(tree, small, big);
	    let res = [];
	    if (split.totNumbers == 1)
	    {
            if(split.data == small)
            	res.push(small);
           else if(split.data == big)
            	res.push(big);
	    }
	    else
	    {
            res = res.concat(search(split.leftChild, small, true));
            res = res.concat(search(split.rightChild, big, false));
        }
    return res;
    }

    function takeAllNum(tree, drawing)
    {
    	if(drawing)
	    {
		    bigFillRect(tree.x, tree.y, nodeWidth, nodeHeight, "#CCCCCC");
		    bigInfo(tree);
		    if (tree.totNumbers != 1)
		    {
			    takeAllNum(tree.leftChild, drawing);
			    takeAllNum(tree.rightChild, drawing);
		    }
	    }
        return tree.totNumbers;
    }

    function numberSearch (tree, x, left, drawing)
    {
    	if(drawing)
        	bigRect(tree.x, tree.y, nodeWidth, nodeHeight, "#ff8800");
    	let num = 0;
    	if(tree.totNumbers == 1)
	    {
		    if (left)
		    {
                if(tree.data >= x)
                	num++;
		    }
		    else
		    {
			    if (tree.data <= x)
				    num++;
		    }
	    }
        else
        {
        	if(left)
            {
            	if(tree.div == x)
                {
                	if(drawing)
                    	bigFillRect(tree.x -5, tree.y, 4, nodeHeight, "#FF0000");
                	num ++; //x is alone on left side
                    num += takeAllNum(tree.rightChild, drawing); //take all on right
                }
                else if (tree.div < x)
                {
                	num += numberSearch(tree.rightChild, x, left, drawing); //search right
                }
                else
                {
                	num += numberSearch(tree.leftChild, x, left, drawing);
                	num += takeAllNum(tree.rightChild, drawing);  //take all right
                }
            }
            else
            {
	            if(tree.div == x)
	            {
		            num += takeAllNum(tree.leftChild, drawing); //x is biggest node on left branch
                }
	            else if (tree.div < x)
	            {
	            	num += takeAllNum(tree.leftChild, drawing);
	            	num += numberSearch(tree.rightChild, x, left, drawing);
	            }
	            else
	            {
	            	num += numberSearch(tree.leftChild, x, left, drawing)
	            }
            }
        }
        return num;
    }

    function numberInRange(tree, small, big, drawing)
    {
    	let res = 0;
        const split = findSplit(tree, small, big);
        if(drawing)
        {
	        bigFillRect(split.x, split.y, nodeWidth, nodeHeight, "#ff00e1");
	        bigInfo(split);
        }
        if(split.totNumbers == 1)
        {
        	if(split.data == small || split.data == big)
        		res ++;
        }
        else
        {
        	res += numberSearch(split.leftChild, small, true, drawing);
        	res += numberSearch(split.rightChild, big, false, drawing);
        }
        return res;
    }

    //VARJE GÅNG VI GÅR HÖGER RISKERAR VI HOPPA ÖVER NUMRET VI SÖKER! Jämför höger hopp med div, och ta div om höger är större än big
    function weightSearch(tree, big, drawing)
    {
    	if(tree.totNumbers == 1)
        {
            return tree.data;
        }
        else if(tree.maxWeight == big)
        	return big;
        else
        {
        	if(tree.div == big)
                return big;
            else if(tree.div > big)
            	return weightSearch(tree.leftChild, big, drawing);
            else
            {
            	let right = weightSearch(tree.rightChild, big, drawing);
                if(right > big)
                	return tree.div;
            	else
            		return right;
            }
        }

    }
    function weightInRange(tree, small, big, drawing)
    {
    	const split = findSplit(tree, small, big);
    	if (split.totNumbers == 1)
        {
        	if(split.data >= small && split.data <= big)
        		return split.data;
        }
        else if(split.maxWeight == big)
            return big;
        else
        {
	        let right = weightSearch(split.rightChild, big, drawing);
	        if(right > big)
		        return split.div;
	        else
		        return right;
        }
    }
    function test (len, start, least, most, small, big)
    {
    	let lastNum = start;
    	let list = [];
    	let ans = [];
    	for (let i = 0; i < len; i++)
        {
        	const random = lastNum + least + Math.floor(Math.random()*(most-least));
        	lastNum = random;
        	list.push(random);
        	if(random >= small && random <= big)
        		ans.push(random);
        }
        const tree = buildTree(null, list);
    	const treeAns = OneDRangeQuery(tree, small, big);
    	const treeNum = numberInRange(tree, small, big, false);
    	const treeWeight = weightInRange(tree, small, big, false);
    	let correct = true;
    	for (let i = 0; i < treeAns.length && correct; i++)
        {
        	if(ans[i] != treeAns[i])
        		correct = false;
        }
        return (correct && (treeNum == ans.length) && (treeWeight == ans[ans.length-1]));
    }
	//const list = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16, 17, 18, 19, 20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66];
	/*let list = [];
	let lastNum = 0;
	for (let i = 0; i < 500; i+=5)
    {
    	//let random = lastNum + Math.floor(Math.random() * 20);
    	//lastNum = random;
        list.push(i);
    }
    const a = buildTree(null, list);
	drawTree(a);
	console.log(OneDRangeQuery(a, 10, 30));
	console.log(numberInRange(a, 10, 30, true));
	console.log(weightInRange(a, 10,29, false));
    */

</script>

</html>